--[[
	
	ESP Library 2
	
	Comet Hub
	
--]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

getgenv().ESPLibConfig = getgenv().ESPLibConfig or {
	ESPEnabled = false,
	ChamsEnabled = false,
	RefreshInterval = 10,
	TeleportThreshold = 100,
	SpeedThreshold = 150,
	MaxUpdatesPerFrame = 3,
	DefaultColor = Color3.fromRGB(145, 19, 255),
	HealthBarEnabled = true,
	DistanceEnabled = false,
	TeamBased = true,
	DarkMode = true,
}

local ESPLibrary = {}

function ESPLibrary:_Initialize()
	self.Connections.Heartbeat = RunService.Heartbeat:Connect(function()
		self:_ProcessUpdateQueue()
		self:_CheckPlayerMovement()
		self:_UpdateDistances()
		self:_UpdateBillboardSizes()
	end)

	self.Connections.PlayerAdded = Players.PlayerAdded:Connect(function(player)
		task.wait(2)
		if player ~= self.LocalPlayer then
			self.PlayersToUpdate[player] = true
		end
	end)

	self.Connections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
		self:_CleanUpPlayer(player)
	end)

	task.spawn(function()
		while true do
			self:_PeriodicRefresh()
			task.wait(self.Config.RefreshInterval)
		end
	end)

	task.spawn(function()
		while true do
			self:_ProcessPlayerUpdates()
			task.wait(0.1)
		end
	end)
end

function ESPLibrary:_CleanUpPlayer(player)
	if not player then return end
	local playerName = player.Name

	if self.ActiveHighlights[playerName] then
		for _, highlight in pairs(self.ActiveHighlights[playerName]) do
			if highlight and highlight.Parent then
				highlight:Destroy()
			end
		end
		self.ActiveHighlights[playerName] = nil
	end

	if self.ActiveBillboards[playerName] then
		for _, billboard in pairs(self.ActiveBillboards[playerName]) do
			if billboard and billboard.Parent then
				billboard:Destroy()
			end
		end
		self.ActiveBillboards[playerName] = nil
	end

	if self.ActiveChams[playerName] then
		for _, cham in pairs(self.ActiveChams[playerName]) do
			if cham and cham.Parent then
				cham:Destroy()
			end
		end
		self.ActiveChams[playerName] = nil
	end

	self.UpdateQueue[playerName] = nil
end

function ESPLibrary:_CreateESP(player, character)
	if not character or not character.Parent or player == self.LocalPlayer then return end

	local playerName = player.Name
	self:_CleanUpPlayer(player)

	self.ActiveHighlights[playerName] = {}
	self.ActiveBillboards[playerName] = {}

	local isDark = self.Config.DarkMode
	local containerBg = isDark and Color3.fromRGB(20, 20, 27) or Color3.fromRGB(255, 255, 255)
	local containerTransparency = isDark and 0.15 or 0.25
	local blurLayerBg = isDark and Color3.fromRGB(25, 25, 35) or Color3.fromRGB(240, 242, 247)
	local blurTransparency = isDark and 0.4 or 0.5
	local textColor = isDark and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(30, 30, 40)
	local distanceColor = isDark and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(60, 60, 67)
	local healthBgColor = isDark and Color3.fromRGB(40, 40, 50) or Color3.fromRGB(0, 0, 0)
	local healthBgTransparency = isDark and 0.7 or 0.88

	local highlight = Instance.new("Highlight")
	highlight.Name = "ESP_Highlight_" .. playerName
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = true
	highlight.FillTransparency = 0.75
	highlight.OutlineTransparency = 0

	local teamColor = self.Config.TeamBased and player.Team and player.TeamColor.Color or self.Config.DefaultColor
	highlight.FillColor = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.6)
	highlight.OutlineColor = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.2)
	highlight.Parent = character
	table.insert(self.ActiveHighlights[playerName], highlight)

	local adornee = character:FindFirstChild("Head") or character:FindFirstChild("UpperTorso")
	if not adornee then return end

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "ESP_BillboardGui_" .. playerName
	billboard.Adornee = adornee
	billboard.Size = UDim2.new(0, 180, 0, 75)
	billboard.StudsOffset = Vector3.new(0, 2.5, 0)
	billboard.AlwaysOnTop = true
	billboard.MaxDistance = 1000
	billboard.Parent = CoreGui
	table.insert(self.ActiveBillboards[playerName], billboard)

	local container = Instance.new("Frame")
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundTransparency = containerTransparency
	container.BackgroundColor3 = containerBg
	container.BorderSizePixel = 0
	container.AnchorPoint = Vector2.new(0.5, 0.5)
	container.Position = UDim2.new(0.5, 0, 0.5, 0)
	container.Parent = billboard

	local containerCorner = Instance.new("UICorner")
	containerCorner.CornerRadius = UDim.new(0, 18)
	containerCorner.Parent = container

	local blurLayer1 = Instance.new("Frame")
	blurLayer1.Size = UDim2.new(1, 0, 1, 0)
	blurLayer1.BackgroundTransparency = blurTransparency
	blurLayer1.BackgroundColor3 = blurLayerBg
	blurLayer1.BorderSizePixel = 0
	blurLayer1.Position = UDim2.new(0, 0, 0, 0)
	blurLayer1.ZIndex = 0
	blurLayer1.Parent = container

	local blur1Corner = Instance.new("UICorner")
	blur1Corner.CornerRadius = UDim.new(0, 18)
	blur1Corner.Parent = blurLayer1
	local gradient = Instance.new("UIGradient")
	if isDark then
		gradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 35)),
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(20, 20, 30)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(15, 15, 25))
		}
	else
		gradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(250, 250, 255)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(245, 247, 252))
		}
	end
	gradient.Rotation = 135
	gradient.Transparency = NumberSequence.new{
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(1, 0.5)
	}
	gradient.Parent = blurLayer1
	local border = Instance.new("UIStroke")
	border.Color = isDark and Color3.fromRGB(80, 80, 90) or Color3.fromRGB(255, 255, 255)
	border.Thickness = 1.2
	border.Transparency = isDark and 0.5 or 0.4
	border.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	border.Parent = container
	local accentBorder = Instance.new("UIStroke")
	accentBorder.Color = teamColor:lerp(Color3.fromRGB(255, 255, 255), isDark and 0.2 or 0.3)
	accentBorder.Thickness = 0.8
	accentBorder.Transparency = 0.6
	accentBorder.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	accentBorder.Parent = blurLayer1
	local shine = Instance.new("Frame")
	shine.Size = UDim2.new(1, 0, 0.35, 0)
	shine.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	shine.BackgroundTransparency = isDark and 0.9 or 0.85
	shine.BorderSizePixel = 0
	shine.Position = UDim2.new(0, 0, 0, 0)
	shine.AnchorPoint = Vector2.new(0, 0)
	shine.ZIndex = 2
	shine.Parent = container

	local shineCorner = Instance.new("UICorner")
	shineCorner.CornerRadius = UDim.new(0, 18)
	shineCorner.Parent = shine

	local shineGradient = Instance.new("UIGradient")
	shineGradient.Transparency = NumberSequence.new{
		NumberSequenceKeypoint.new(0, isDark and 0.5 or 0.3),
		NumberSequenceKeypoint.new(0.7, 0.9),
		NumberSequenceKeypoint.new(1, 1)
	}
	shineGradient.Rotation = 90
	shineGradient.Parent = shine

	local playerIcon
	if self.Config.NametagEnabled then
		local nameContainer = Instance.new("Frame")
		nameContainer.Size = UDim2.new(1, -20, 0, 24)
		nameContainer.Position = UDim2.new(0, 10, 0, 10)
		nameContainer.AnchorPoint = Vector2.new(0, 0)
		nameContainer.BackgroundTransparency = 1
		nameContainer.ZIndex = 3
		nameContainer.Parent = container

		playerIcon = Instance.new("TextLabel")
		playerIcon.Text = "â—"
		playerIcon.Size = UDim2.new(0, 12, 0, 12)
		playerIcon.Position = UDim2.new(0, 0, 0, 6)
		playerIcon.AnchorPoint = Vector2.new(0, 0)
		playerIcon.TextColor3 = teamColor
		playerIcon.TextSize = 20
		playerIcon.BackgroundTransparency = 1
		playerIcon.Font = Enum.Font.GothamBold
		playerIcon.ZIndex = 4
		playerIcon.Parent = nameContainer

		local label = Instance.new("TextLabel")
		label.Text = player.Name
		label.Size = UDim2.new(1, -20, 1, 0)
		label.Position = UDim2.new(0, 20, 0, 0)
		label.AnchorPoint = Vector2.new(0, 0)
		label.TextColor3 = textColor
		label.TextStrokeTransparency = 1
		label.Font = Enum.Font.GothamMedium
		label.TextSize = 15
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.BackgroundTransparency = 1
		label.TextTruncate = Enum.TextTruncate.AtEnd
		label.ZIndex = 4
		label.Parent = nameContainer
	end

	if self.Config.HealthBarEnabled then
		local healthContainer = Instance.new("Frame")
		healthContainer.Size = UDim2.new(1, -20, 0, 20)
		healthContainer.Position = UDim2.new(0, 10, 0, 40)
		healthContainer.AnchorPoint = Vector2.new(0, 0)
		healthContainer.BackgroundColor3 = healthBgColor
		healthContainer.BackgroundTransparency = healthBgTransparency
		healthContainer.BorderSizePixel = 0
		healthContainer.ZIndex = 3
		healthContainer.Parent = container

		local healthCorner = Instance.new("UICorner")
		healthCorner.CornerRadius = UDim.new(1, 0)
		healthCorner.Parent = healthContainer
		
		local innerShadow = Instance.new("UIStroke")
		innerShadow.Color = Color3.fromRGB(0, 0, 0)
		innerShadow.Thickness = 1
		innerShadow.Transparency = isDark and 0.85 or 0.92
		innerShadow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		innerShadow.Parent = healthContainer

		local healthFill = Instance.new("Frame")
		healthFill.Size = UDim2.new(1, -4, 1, -4)
		healthFill.Position = UDim2.new(0, 2, 0, 2)
		healthFill.AnchorPoint = Vector2.new(0, 0)
		healthFill.BackgroundColor3 = Color3.fromRGB(52, 199, 89)
		healthFill.BorderSizePixel = 0
		healthFill.ZIndex = 4
		healthFill.Parent = healthContainer

		local healthFillCorner = Instance.new("UICorner")
		healthFillCorner.CornerRadius = UDim.new(1, 0)
		healthFillCorner.Parent = healthFill

		-- Vibrant iOS health gradient
		local healthGradient = Instance.new("UIGradient")
		healthGradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(52, 199, 89)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(48, 209, 88))
		}
		healthGradient.Rotation = 90
		healthGradient.Parent = healthFill

		-- Glossy overlay on health bar
		local healthShine = Instance.new("Frame")
		healthShine.Size = UDim2.new(1, 0, 0.5, 0)
		healthShine.Position = UDim2.new(0, 0, 0, 0)
		healthShine.AnchorPoint = Vector2.new(0, 0)
		healthShine.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		healthShine.BackgroundTransparency = 0.7
		healthShine.BorderSizePixel = 0
		healthShine.ZIndex = 5
		healthShine.Parent = healthFill

		local healthShineCorner = Instance.new("UICorner")
		healthShineCorner.CornerRadius = UDim.new(1, 0)
		healthShineCorner.Parent = healthShine

		local healthShineGradient = Instance.new("UIGradient")
		healthShineGradient.Transparency = NumberSequence.new{
			NumberSequenceKeypoint.new(0, 0.4),
			NumberSequenceKeypoint.new(1, 1)
		}
		healthShineGradient.Rotation = 90
		healthShineGradient.Parent = healthShine

		local healthText = Instance.new("TextLabel")
		healthText.Size = UDim2.new(1, -16, 1, 0)
		healthText.Position = UDim2.new(0, 8, 0, 0)
		healthText.AnchorPoint = Vector2.new(0, 0)
		healthText.Text = "100%"
		healthText.TextColor3 = Color3.fromRGB(255, 255, 255)
		healthText.TextStrokeTransparency = 0.3
		healthText.Font = Enum.Font.MontserratBold
		healthText.TextSize = 12
		healthText.BackgroundTransparency = 1
		healthText.TextXAlignment = Enum.TextXAlignment.Center
		healthText.ZIndex = 6
		healthText.Parent = healthFill

		self.UpdateQueue[playerName] = {
			healthFill = healthFill,
			healthText = healthText,
			healthGradient = healthGradient,
			healthShine = healthShine,
			highlight = highlight,
			border = border,
			accentBorder = accentBorder,
			playerIcon = playerIcon,
			player = player,
		}
	else
		self.UpdateQueue[playerName] = {
			healthFill = nil,
			healthText = nil,
			healthGradient = nil,
			healthShine = nil,
			highlight = highlight,
			border = border,
			accentBorder = accentBorder,
			playerIcon = playerIcon,
			player = player,
		}
	end

	if self.Config.DistanceEnabled then
		local distanceLabel = Instance.new("TextLabel")
		distanceLabel.Name = "DistanceLabel"
		distanceLabel.Size = UDim2.new(1, -20, 0, 18)
		distanceLabel.Position = UDim2.new(0, 10, 0, 55)
		distanceLabel.AnchorPoint = Vector2.new(0, 0)
		distanceLabel.Text = "0m"
		distanceLabel.TextColor3 = distanceColor
		distanceLabel.TextStrokeTransparency = 1
		distanceLabel.Font = Enum.Font.MontserratBold
		distanceLabel.TextSize = 13
		distanceLabel.BackgroundTransparency = 1
		distanceLabel.TextXAlignment = Enum.TextXAlignment.Center
		distanceLabel.ZIndex = 4
		distanceLabel.Parent = container

		if self.UpdateQueue[playerName] then
			self.UpdateQueue[playerName].distanceLabel = distanceLabel
		end
	end
end

function ESPLibrary:_CreateChams(player, character)
	if not character or not character.Parent or player == self.LocalPlayer then return end

	local playerName = player.Name

	if self.ActiveChams[playerName] then
		for _, cham in pairs(self.ActiveChams[playerName]) do
			if cham and cham.Parent then
				cham:Destroy()
			end
		end
	end

	local highlight = Instance.new("Highlight")
	highlight.Name = "Chams_" .. playerName
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = true
	highlight.FillTransparency = 0.65
	highlight.OutlineTransparency = 0

	local teamColor = self.Config.TeamBased and player.Team and player.TeamColor.Color or self.Config.DefaultColor
	highlight.FillColor = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.5)
	highlight.OutlineColor = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.3)
	highlight.Parent = character

	self.ActiveChams[playerName] = {highlight}
end

function ESPLibrary:_ProcessUpdateQueue()
	if not self.Config.ESPEnabled then return end

	local updatesProcessed = 0
	for playerName, data in pairs(self.UpdateQueue) do
		if updatesProcessed >= self.Config.MaxUpdatesPerFrame then break end

		local player = data.player
		local character = player and player.Character
		local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")

		if not character or not humanoid then
			self:_CleanUpPlayer(player)
			updatesProcessed = updatesProcessed + 1
			continue
		end

		local health = humanoid.Health
		local maxHealth = humanoid.MaxHealth
		local percentage = maxHealth > 0 and health / maxHealth or 0
		
		TweenService:Create(data.healthFill, TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), {
			Size = UDim2.new(percentage, -4, 1, -4)
		}):Play()

		data.healthText.Text = string.format("%d%%", math.floor(percentage * 100))
		local healthColor
		if percentage <= 0.2 then
			healthColor = Color3.fromRGB(255, 59, 48) -- Red
			data.healthGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(226, 52, 43)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(212, 56, 48))
			}
		elseif percentage <= 0.5 then
			healthColor = Color3.fromRGB(255, 149, 0) -- Orange
			data.healthGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 149, 0)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 159, 10))
			}
		elseif percentage <= 0.75 then
			healthColor = Color3.fromRGB(240, 255, 70) -- Yellow
			data.healthGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(240, 255, 70)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(206, 216, 59))
			}
		else
			healthColor = Color3.fromRGB(0, 255, 94) -- Green
			data.healthGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 128)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(6, 204, 105))
			}
		end

		data.healthFill.BackgroundColor3 = healthColor

		local teamColor = self.Config.TeamBased and player.Team and player.TeamColor.Color or self.Config.DefaultColor
		data.highlight.FillColor = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.6)
		data.highlight.OutlineColor = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.2)
		data.accentBorder.Color = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.3)
		data.playerIcon.TextColor3 = teamColor

		updatesProcessed = updatesProcessed + 1
	end
end

function ESPLibrary:_UpdateBillboardSizes()
	if not self.Config.ESPEnabled then return end

	local camera = workspace.CurrentCamera
	if not camera then return end

	for playerName, billboards in pairs(self.ActiveBillboards) do
		for _, billboard in pairs(billboards) do
			if billboard and billboard.Parent and billboard.Adornee then
				local adornee = billboard.Adornee
				local baseWidth = 180
				local baseHeight = 75
				billboard.Size = UDim2.new(0, baseWidth, 0, baseHeight)
				local character = adornee.Parent
				local hrp = character and character:FindFirstChild("HumanoidRootPart")

				if hrp and character then
					local baseOffset = 3
					local characterTop = -math.huge
					local characterBottom = math.huge

					for _, part in pairs(character:GetChildren()) do
						if part:IsA("BasePart") then
							local partTop = part.Position.Y + (part.Size.Y / 2)
							local partBottom = part.Position.Y - (part.Size.Y / 2)
							characterTop = math.max(characterTop, partTop)
							characterBottom = math.min(characterBottom, partBottom)
						end
					end
					local headPos = adornee.Position
					local billboardWorldY = headPos.Y + baseOffset
					local billboardWorldPos = Vector3.new(headPos.X, billboardWorldY, headPos.Z)
					local characterTopPos = Vector3.new(hrp.Position.X, characterTop, hrp.Position.Z)

					local billboardScreen, billboardOnScreen = camera:WorldToScreenPoint(billboardWorldPos)
					local charTopScreen, charTopOnScreen = camera:WorldToScreenPoint(characterTopPos)

					if billboardOnScreen and charTopOnScreen then
						local billboardBottomY = billboardScreen.Y + (baseHeight / 2)
						local characterTopY = charTopScreen.Y
						if billboardBottomY > characterTopY then
							local overlapPixels = billboardBottomY - characterTopY
							local distance = (camera.CFrame.Position - hrp.Position).Magnitude
							local pixelToStud = distance / 100
							local extraOffset = (overlapPixels * pixelToStud) / 10

							billboard.StudsOffset = Vector3.new(0, baseOffset + extraOffset + 1, 0)
						else
							billboard.StudsOffset = Vector3.new(0, baseOffset, 0)
						end
					else
						billboard.StudsOffset = Vector3.new(0, baseOffset, 0)
					end
				else
					-- Fallback
					billboard.StudsOffset = Vector3.new(0, 2.5, 0)
				end
			end
		end
	end
end

function ESPLibrary:_UpdateDistances()
	if not self.Config.DistanceEnabled or not self.Config.ESPEnabled then return end

	local hrp = self.LocalPlayer.Character and self.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	for playerName, data in pairs(self.UpdateQueue) do
		if data.distanceLabel then
			local player = data.player
			local character = player and player.Character
			local targetHRP = character and character:FindFirstChild("HumanoidRootPart")

			if targetHRP then
				local distance = (hrp.Position - targetHRP.Position).Magnitude
				data.distanceLabel.Text = string.format("%dm", math.floor(distance))
			end
		end
	end
end

function ESPLibrary:_ProcessPlayerUpdates()
	for player, _ in pairs(self.PlayersToUpdate) do
		if not self.Config.ESPEnabled and not self.Config.ChamsEnabled then
			self:_CleanUpPlayer(player)
			self.PlayersToUpdate[player] = nil
			continue
		end

		local character = player.Character
		if character then
			if self.Config.ESPEnabled then
				self:_CreateESP(player, character)
			end
			if self.Config.ChamsEnabled then
				self:_CreateChams(player, character)
			end
		end

		self.PlayersToUpdate[player] = nil
	end
end

function ESPLibrary:_CheckPlayerMovement()
	if not self.Config.ESPEnabled and not self.Config.ChamsEnabled then return end

	local hrp = self.LocalPlayer.Character and self.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local currentPos = hrp.Position
	local distance = (currentPos - self.LastPosition).Magnitude
	local currentTime = os.time()

	if distance > self.Config.TeleportThreshold or 
		(currentTime - self.LastCheck > 1 and (distance / (currentTime - self.LastCheck)) > self.Config.SpeedThreshold) then
		self:RefreshAll()
	end

	self.LastPosition = currentPos
	self.LastCheck = currentTime
end

function ESPLibrary:_PeriodicRefresh()
	if not self.Config.ESPEnabled and not self.Config.ChamsEnabled then return end

	for playerName, _ in pairs(self.ActiveHighlights) do
		local player = Players:FindFirstChild(playerName)
		if not player then
			self:_CleanUpPlayer({Name = playerName})
		end
	end

	self:RefreshAll()
end

function ESPLibrary:EnableESP()
	self.Config.ESPEnabled = true
	self.Config.ChamsEnabled = false
	self:RefreshAll()
end

function ESPLibrary:DisableESP()
	self.Config.ESPEnabled = false
	for _, player in pairs(Players:GetPlayers()) do
		self:_CleanUpPlayer(player)
	end
	self.UpdateQueue = {}
	self.PlayersToUpdate = {}
end

function ESPLibrary:EnableChams()
	self.Config.ChamsEnabled = true
	self.Config.ESPEnabled = false
	self:ClearAllESP()
	self:RefreshAll()
end

function ESPLibrary:DisableChams()
	self.Config.ChamsEnabled = false
	for playerName, chams in pairs(self.ActiveChams) do
		for _, cham in pairs(chams) do
			if cham and cham.Parent then
				cham:Destroy()
			end
		end
	end
	self.ActiveChams = {}
end

function ESPLibrary:ClearAllESP()
	for _, player in pairs(Players:GetPlayers()) do
		self:_CleanUpPlayer(player)
	end
	self.UpdateQueue = {}
	self.PlayersToUpdate = {}
	self.ActiveHighlights = {}
	self.ActiveBillboards = {}
end

function ESPLibrary:ClearAllChams()
	for playerName, chams in pairs(self.ActiveChams) do
		for _, cham in pairs(chams) do
			if cham and cham.Parent then
				cham:Destroy()
			end
		end
	end
	self.ActiveChams = {}
end

function ESPLibrary:RefreshAll()
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= self.LocalPlayer then
			self.PlayersToUpdate[player] = true
		end
	end
end

function ESPLibrary:SetESPColor(color)
	self.Config.DefaultColor = color
	self:RefreshAll()
end

function ESPLibrary:SetTeamBased(enabled)
	self.Config.TeamBased = enabled
	self:RefreshAll()
end

function ESPLibrary:SetHealthBarEnabled(enabled)
	self.Config.HealthBarEnabled = enabled
	self:RefreshAll()
end

function ESPLibrary:SetNametagEnabled(enabled)
	self.Config.NametagEnabled = enabled
	self:RefreshAll()
end

function ESPLibrary:SetDistanceEnabled(enabled)
	self.Config.DistanceEnabled = enabled
	self:RefreshAll()
end

function ESPLibrary:SetDarkMode(enabled)
	self.Config.DarkMode = enabled
	self:RefreshAll()
end

function ESPLibrary:IsESPEnabled()
	return self.Config.ESPEnabled
end

function ESPLibrary:IsChamsEnabled()
	return self.Config.ChamsEnabled
end

function ESPLibrary:Destroy()
	self:ClearAllESP()
	self:ClearAllChams()

	for _, connection in pairs(self.Connections) do
		if connection then
			connection:Disconnect()
		end
	end

	setmetatable(self, nil)
end

local function CreateInstance()
	local instance = setmetatable({}, {__index = ESPLibrary})

	instance.Config = getgenv().ESPLibConfig
	instance.LocalPlayer = Players.LocalPlayer
	instance.ActiveHighlights = {}
	instance.ActiveBillboards = {}
	instance.ActiveChams = {}
	instance.PlayersToUpdate = {}
	instance.UpdateQueue = {}
	instance.LastPosition = Vector3.new(0, 0, 0)
	instance.LastCheck = os.time()
	instance.Connections = {}

	instance:_Initialize()

	if instance.Config.ESPEnabled then
		instance:RefreshAll()
	elseif instance.Config.ChamsEnabled then
		instance:RefreshAll()
	end

	return instance
end

return CreateInstance()
