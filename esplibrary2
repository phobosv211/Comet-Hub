--[[
	
	ESP Library 3 - Enhanced Visual Design
	
	Comet Hub
	
--]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

getgenv().ESPLibConfig = getgenv().ESPLibConfig or {
	ESPEnabled = false,
	ChamsEnabled = false,
	RefreshInterval = 10,
	TeleportThreshold = 100,
	SpeedThreshold = 150,
	MaxUpdatesPerFrame = 3,
	DefaultColor = Color3.fromRGB(88, 166, 255),
	HealthBarEnabled = true,
	NametagEnabled = true,
	DistanceEnabled = true,
	TeamBased = true,
	BoxESP = false,
}

local ESPLibrary = {}

function ESPLibrary:_Initialize()
	self.Connections.Heartbeat = RunService.Heartbeat:Connect(function()
		self:_ProcessUpdateQueue()
		self:_CheckPlayerMovement()
		self:_UpdateDistances()
	end)

	self.Connections.PlayerAdded = Players.PlayerAdded:Connect(function(player)
		task.wait(2)
		if player ~= self.LocalPlayer then
			self.PlayersToUpdate[player] = true
		end
	end)

	self.Connections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
		self:_CleanUpPlayer(player)
	end)

	task.spawn(function()
		while true do
			self:_PeriodicRefresh()
			task.wait(self.Config.RefreshInterval)
		end
	end)

	task.spawn(function()
		while true do
			self:_ProcessPlayerUpdates()
			task.wait(0.1)
		end
	end)
end

function ESPLibrary:_CleanUpPlayer(player)
	if not player then return end
	local playerName = player.Name

	if self.ActiveHighlights[playerName] then
		for _, highlight in pairs(self.ActiveHighlights[playerName]) do
			if highlight and highlight.Parent then
				highlight:Destroy()
			end
		end
		self.ActiveHighlights[playerName] = nil
	end

	if self.ActiveBillboards[playerName] then
		for _, billboard in pairs(self.ActiveBillboards[playerName]) do
			if billboard and billboard.Parent then
				billboard:Destroy()
			end
		end
		self.ActiveBillboards[playerName] = nil
	end

	if self.ActiveChams[playerName] then
		for _, cham in pairs(self.ActiveChams[playerName]) do
			if cham and cham.Parent then
				cham:Destroy()
			end
		end
		self.ActiveChams[playerName] = nil
	end

	self.UpdateQueue[playerName] = nil
end

function ESPLibrary:_CreateESP(player, character)
	if not character or not character.Parent or player == self.LocalPlayer then return end

	local playerName = player.Name
	self:_CleanUpPlayer(player)

	self.ActiveHighlights[playerName] = {}
	self.ActiveBillboards[playerName] = {}

	-- Enhanced Highlight with better visibility
	local highlight = Instance.new("Highlight")
	highlight.Name = "ESP_Highlight_" .. playerName
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = true
	highlight.FillTransparency = 0.6
	highlight.OutlineTransparency = 0.3

	local teamColor = self.Config.TeamBased and player.Team and player.TeamColor.Color or self.Config.DefaultColor
	highlight.FillColor = teamColor
	highlight.OutlineColor = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.3)
	highlight.Parent = character
	table.insert(self.ActiveHighlights[playerName], highlight)

	local adornee = character:FindFirstChild("Head") or character:FindFirstChild("UpperTorso")
	if not adornee then return end

	-- Modern Billboard with gradient and glass effect
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "ESP_BillboardGui_" .. playerName
	billboard.Adornee = adornee
	billboard.Size = UDim2.new(0, 200, 0, 90)
	billboard.StudsOffset = Vector3.new(0, 3.5, 0)
	billboard.AlwaysOnTop = true
	billboard.Parent = CoreGui
	table.insert(self.ActiveBillboards[playerName], billboard)

	-- Glass morphism container
	local container = Instance.new("Frame")
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundTransparency = 0.15
	container.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
	container.BorderSizePixel = 0
	container.Parent = billboard

	local containerCorner = Instance.new("UICorner")
	containerCorner.CornerRadius = UDim.new(0, 10)
	containerCorner.Parent = container

	-- Gradient overlay for depth
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 35)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(15, 15, 20))
	}
	gradient.Rotation = 90
	gradient.Parent = container

	-- Accent border glow
	local border = Instance.new("UIStroke")
	border.Color = teamColor
	border.Thickness = 1.5
	border.Transparency = 0.3
	border.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	border.Parent = container

	-- Top accent bar
	local accentBar = Instance.new("Frame")
	accentBar.Size = UDim2.new(1, 0, 0, 3)
	accentBar.BackgroundColor3 = teamColor
	accentBar.BorderSizePixel = 0
	accentBar.Position = UDim2.new(0, 0, 0, 0)
	accentBar.Parent = container

	local accentCorner = Instance.new("UICorner")
	accentCorner.CornerRadius = UDim.new(0, 10)
	accentCorner.Parent = accentBar

	if self.Config.NametagEnabled then
		-- Player name with icon
		local nameContainer = Instance.new("Frame")
		nameContainer.Size = UDim2.new(1, -16, 0, 22)
		nameContainer.Position = UDim2.new(0, 8, 0, 8)
		nameContainer.BackgroundTransparency = 1
		nameContainer.Parent = container

		local playerIcon = Instance.new("TextLabel")
		playerIcon.Text = "üë§"
		playerIcon.Size = UDim2.new(0, 18, 0, 18)
		playerIcon.Position = UDim2.new(0, 0, 0, 2)
		playerIcon.TextColor3 = teamColor
		playerIcon.TextSize = 14
		playerIcon.BackgroundTransparency = 1
		playerIcon.Font = Enum.Font.GothamBold
		playerIcon.Parent = nameContainer

		local label = Instance.new("TextLabel")
		label.Text = player.Name
		label.Size = UDim2.new(1, -24, 1, 0)
		label.Position = UDim2.new(0, 24, 0, 0)
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextStrokeTransparency = 0.5
		label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
		label.Font = Enum.Font.GothamBold
		label.TextSize = 15
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.BackgroundTransparency = 1
		label.TextTruncate = Enum.TextTruncate.AtEnd
		label.Parent = nameContainer
	end

	if self.Config.HealthBarEnabled then
		-- Health bar with modern design
		local healthContainer = Instance.new("Frame")
		healthContainer.Size = UDim2.new(1, -16, 0, 18)
		healthContainer.Position = UDim2.new(0, 8, 0, 36)
		healthContainer.BackgroundColor3 = Color3.fromRGB(20, 20, 28)
		healthContainer.BorderSizePixel = 0
		healthContainer.Parent = container

		local healthCorner = Instance.new("UICorner")
		healthCorner.CornerRadius = UDim.new(0, 6)
		healthCorner.Parent = healthContainer

		local healthStroke = Instance.new("UIStroke")
		healthStroke.Color = Color3.fromRGB(40, 40, 50)
		healthStroke.Thickness = 1
		healthStroke.Transparency = 0.5
		healthStroke.Parent = healthContainer

		local healthFill = Instance.new("Frame")
		healthFill.Size = UDim2.new(1, 0, 1, 0)
		healthFill.BackgroundColor3 = Color3.fromRGB(46, 213, 115)
		healthFill.BorderSizePixel = 0
		healthFill.Parent = healthContainer

		local healthFillCorner = Instance.new("UICorner")
		healthFillCorner.CornerRadius = UDim.new(0, 6)
		healthFillCorner.Parent = healthFill

		-- Health gradient
		local healthGradient = Instance.new("UIGradient")
		healthGradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(46, 213, 115)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(72, 219, 129))
		}
		healthGradient.Rotation = 90
		healthGradient.Parent = healthFill

		-- Health icon
		local healthIcon = Instance.new("TextLabel")
		healthIcon.Text = "‚ù§"
		healthIcon.Size = UDim2.new(0, 16, 1, 0)
		healthIcon.Position = UDim2.new(0, 4, 0, 0)
		healthIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
		healthIcon.TextSize = 12
		healthIcon.BackgroundTransparency = 1
		healthIcon.Font = Enum.Font.GothamBold
		healthIcon.ZIndex = 2
		healthIcon.Parent = healthContainer

		local healthText = Instance.new("TextLabel")
		healthText.Size = UDim2.new(1, -24, 1, 0)
		healthText.Position = UDim2.new(0, 24, 0, 0)
		healthText.Text = "100 HP"
		healthText.TextColor3 = Color3.fromRGB(255, 255, 255)
		healthText.TextStrokeTransparency = 0.6
		healthText.Font = Enum.Font.GothamBold
		healthText.TextSize = 13
		healthText.BackgroundTransparency = 1
		healthText.TextXAlignment = Enum.TextXAlignment.Left
		healthText.ZIndex = 2
		healthText.Parent = healthContainer

		self.UpdateQueue[playerName] = {
			healthFill = healthFill,
			healthText = healthText,
			healthGradient = healthGradient,
			highlight = highlight,
			border = border,
			accentBar = accentBar,
			player = player,
		}
	end

	if self.Config.DistanceEnabled then
		-- Distance indicator
		local distanceLabel = Instance.new("TextLabel")
		distanceLabel.Name = "DistanceLabel"
		distanceLabel.Size = UDim2.new(1, -16, 0, 18)
		distanceLabel.Position = UDim2.new(0, 8, 0, 60)
		distanceLabel.Text = "üìç 0m"
		distanceLabel.TextColor3 = Color3.fromRGB(200, 200, 210)
		distanceLabel.TextStrokeTransparency = 0.6
		distanceLabel.Font = Enum.Font.Gotham
		distanceLabel.TextSize = 12
		distanceLabel.BackgroundTransparency = 1
		distanceLabel.TextXAlignment = Enum.TextXAlignment.Left
		distanceLabel.Parent = container

		if self.UpdateQueue[playerName] then
			self.UpdateQueue[playerName].distanceLabel = distanceLabel
		end
	end
end

function ESPLibrary:_CreateChams(player, character)
	if not character or not character.Parent or player == self.LocalPlayer then return end

	local playerName = player.Name

	if self.ActiveChams[playerName] then
		for _, cham in pairs(self.ActiveChams[playerName]) do
			if cham and cham.Parent then
				cham:Destroy()
			end
		end
	end

	local highlight = Instance.new("Highlight")
	highlight.Name = "Chams_" .. playerName
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = true
	highlight.FillTransparency = 0.4
	highlight.OutlineTransparency = 0.2

	local teamColor = self.Config.TeamBased and player.Team and player.TeamColor.Color or self.Config.DefaultColor
	highlight.FillColor = teamColor
	highlight.OutlineColor = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.4)
	highlight.Parent = character

	self.ActiveChams[playerName] = {highlight}
end

function ESPLibrary:_ProcessUpdateQueue()
	if not self.Config.ESPEnabled then return end

	local updatesProcessed = 0
	for playerName, data in pairs(self.UpdateQueue) do
		if updatesProcessed >= self.Config.MaxUpdatesPerFrame then break end

		local player = data.player
		local character = player and player.Character
		local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")

		if not character or not humanoid then
			self:_CleanUpPlayer(player)
			updatesProcessed = updatesProcessed + 1
			continue
		end

		local health = humanoid.Health
		local maxHealth = humanoid.MaxHealth
		local percentage = maxHealth > 0 and health / maxHealth or 0

		-- Smooth health bar animation
		TweenService:Create(data.healthFill, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Size = UDim2.new(percentage, 0, 1, 0)
		}):Play()

		data.healthText.Text = string.format("%d HP", math.floor(health))

		-- Dynamic health color with gradient
		local healthColor
		if percentage <= 0.25 then
			healthColor = Color3.fromRGB(255, 71, 87)
			data.healthGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 71, 87)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 107, 107))
			}
		elseif percentage <= 0.5 then
			healthColor = Color3.fromRGB(255, 177, 66)
			data.healthGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 177, 66)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 195, 113))
			}
		else
			healthColor = Color3.fromRGB(46, 213, 115)
			data.healthGradient.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(46, 213, 115)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(72, 219, 129))
			}
		end

		local teamColor = self.Config.TeamBased and player.Team and player.TeamColor.Color or self.Config.DefaultColor
		data.highlight.FillColor = teamColor
		data.highlight.OutlineColor = teamColor:lerp(Color3.fromRGB(255, 255, 255), 0.3)
		data.border.Color = teamColor
		data.accentBar.BackgroundColor3 = teamColor

		updatesProcessed = updatesProcessed + 1
	end
end

function ESPLibrary:_UpdateDistances()
	if not self.Config.DistanceEnabled or not self.Config.ESPEnabled then return end

	local hrp = self.LocalPlayer.Character and self.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	for playerName, data in pairs(self.UpdateQueue) do
		if data.distanceLabel then
			local player = data.player
			local character = player and player.Character
			local targetHRP = character and character:FindFirstChild("HumanoidRootPart")

			if targetHRP then
				local distance = (hrp.Position - targetHRP.Position).Magnitude
				data.distanceLabel.Text = string.format("üìç %dm", math.floor(distance))
			end
		end
	end
end

function ESPLibrary:_ProcessPlayerUpdates()
	for player, _ in pairs(self.PlayersToUpdate) do
		if not self.Config.ESPEnabled and not self.Config.ChamsEnabled then
			self:_CleanUpPlayer(player)
			self.PlayersToUpdate[player] = nil
			continue
		end

		local character = player.Character
		if character then
			if self.Config.ESPEnabled then
				self:_CreateESP(player, character)
			end
			if self.Config.ChamsEnabled then
				self:_CreateChams(player, character)
			end
		end

		self.PlayersToUpdate[player] = nil
	end
end

function ESPLibrary:_CheckPlayerMovement()
	if not self.Config.ESPEnabled and not self.Config.ChamsEnabled then return end

	local hrp = self.LocalPlayer.Character and self.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local currentPos = hrp.Position
	local distance = (currentPos - self.LastPosition).Magnitude
	local currentTime = os.time()

	if distance > self.Config.TeleportThreshold or 
		(currentTime - self.LastCheck > 1 and (distance / (currentTime - self.LastCheck)) > self.Config.SpeedThreshold) then
		self:RefreshAll()
	end

	self.LastPosition = currentPos
	self.LastCheck = currentTime
end

function ESPLibrary:_PeriodicRefresh()
	if not self.Config.ESPEnabled and not self.Config.ChamsEnabled then return end

	for playerName, _ in pairs(self.ActiveHighlights) do
		local player = Players:FindFirstChild(playerName)
		if not player then
			self:_CleanUpPlayer({Name = playerName})
		end
	end

	self:RefreshAll()
end

function ESPLibrary:EnableESP()
	self.Config.ESPEnabled = true
	self.Config.ChamsEnabled = false
	self:RefreshAll()
end

function ESPLibrary:DisableESP()
	self.Config.ESPEnabled = false
	for _, player in pairs(Players:GetPlayers()) do
		self:_CleanUpPlayer(player)
	end
	self.UpdateQueue = {}
	self.PlayersToUpdate = {}
end

function ESPLibrary:EnableChams()
	self.Config.ChamsEnabled = true
	self.Config.ESPEnabled = false
	self:ClearAllESP()
	self:RefreshAll()
end

function ESPLibrary:DisableChams()
	self.Config.ChamsEnabled = false
	for playerName, chams in pairs(self.ActiveChams) do
		for _, cham in pairs(chams) do
			if cham and cham.Parent then
				cham:Destroy()
			end
		end
	end
	self.ActiveChams = {}
end

function ESPLibrary:ClearAllESP()
	for _, player in pairs(Players:GetPlayers()) do
		self:_CleanUpPlayer(player)
	end
	self.UpdateQueue = {}
	self.PlayersToUpdate = {}
	self.ActiveHighlights = {}
	self.ActiveBillboards = {}
end

function ESPLibrary:ClearAllChams()
	for playerName, chams in pairs(self.ActiveChams) do
		for _, cham in pairs(chams) do
			if cham and cham.Parent then
				cham:Destroy()
			end
		end
	end
	self.ActiveChams = {}
end

function ESPLibrary:RefreshAll()
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= self.LocalPlayer then
			self.PlayersToUpdate[player] = true
		end
	end
end

function ESPLibrary:SetESPColor(color)
	self.Config.DefaultColor = color
	self:RefreshAll()
end

function ESPLibrary:SetTeamBased(enabled)
	self.Config.TeamBased = enabled
	self:RefreshAll()
end

function ESPLibrary:SetHealthBarEnabled(enabled)
	self.Config.HealthBarEnabled = enabled
	self:RefreshAll()
end

function ESPLibrary:SetNametagEnabled(enabled)
	self.Config.NametagEnabled = enabled
	self:RefreshAll()
end

function ESPLibrary:SetDistanceEnabled(enabled)
	self.Config.DistanceEnabled = enabled
	self:RefreshAll()
end

function ESPLibrary:IsESPEnabled()
	return self.Config.ESPEnabled
end

function ESPLibrary:IsChamsEnabled()
	return self.Config.ChamsEnabled
end

function ESPLibrary:Destroy()
	self:ClearAllESP()
	self:ClearAllChams()

	for _, connection in pairs(self.Connections) do
		if connection then
			connection:Disconnect()
		end
	end

	setmetatable(self, nil)
end

local function CreateInstance()
	local instance = setmetatable({}, {__index = ESPLibrary})

	instance.Config = getgenv().ESPLibConfig
	instance.LocalPlayer = Players.LocalPlayer
	instance.ActiveHighlights = {}
	instance.ActiveBillboards = {}
	instance.ActiveChams = {}
	instance.PlayersToUpdate = {}
	instance.UpdateQueue = {}
	instance.LastPosition = Vector3.new(0, 0, 0)
	instance.LastCheck = os.time()
	instance.Connections = {}

	instance:_Initialize()

	if instance.Config.ESPEnabled then
		instance:RefreshAll()
	elseif instance.Config.ChamsEnabled then
		instance:RefreshAll()
	end

	return instance
end

return CreateInstance()
